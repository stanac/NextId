using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NextId.Gen
{
    [Generator]
    public class NextIdGenerator : IIncrementalGenerator
    {
        private const string AttributeFullName = "NextId.IdentifierAttribute";
        private const int MaxPrefixLength = 11;
        private const int MinPrefixLength = 3;
        private const int MaxSaltLength = 32;

        private const string AttributeSourceCode = @"// <auto-generated/>
#nullable enable
namespace NextId
{
    /// <summary>
    /// Attribute for the NextId source generator to create a strongly-typed identifier.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class IdentifierAttribute : System.Attribute
    {
        /// <summary>
        /// The prefix for the generated Id. Must be 3-11 ASCII letters or digits with no whitespace.
        /// </summary>
        public string Prefix { get; set; } = """";

        /// <summary>
        /// The salt used for hashing the checksum. Cannot be empty or contain whitespace. Max 32 characters.
        /// </summary>
        public string Salt { get; set; } = """";
    }
}
";

        #region Diagnostics

        private static readonly DiagnosticDescriptor PrefixNotSetError = new(
            id: "NEXTID001",
            title: "Prefix is not set",
            messageFormat: "The Prefix property must be set and cannot be empty or whitespace,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor PrefixTooLongError = new(
            id: "NEXTID002",
            title: "Prefix is too long",
            messageFormat: "The Prefix '{0}' cannot be longer than {1} characters,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor PrefixTooShortError = new(
            id: "NEXTID003",
            title: "Prefix is too short",
            messageFormat: "The Prefix '{0}' must be at least {1} characters long,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor PrefixContainsWhitespaceError = new(
            id: "NEXTID004",
            title: "Prefix contains whitespace",
            messageFormat: "The Prefix '{0}' cannot contain whitespace characters,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor SaltNotSetError = new(
            id: "NEXTID005",
            title: "Salt is not set",
            messageFormat: "The Salt property must be set and cannot be empty or whitespace,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor SaltTooLongError = new(
            id: "NEXTID006",
            title: "Salt is too long",
            messageFormat: "The Salt cannot be longer than {0} characters,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor SaltContainsWhitespaceError = new(
            id: "NEXTID007",
            title: "Salt contains whitespace",
            messageFormat: "The Salt cannot contain whitespace characters,",
            category: "NextId.Generator",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        #endregion

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                "IdentifierAttribute.g.cs",
                AttributeSourceCode));

            IncrementalValuesProvider<GeneratorAttributeSyntaxContext> classDeclarations =
                context.SyntaxProvider.ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: AttributeFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, _) => ctx);

            context.RegisterSourceOutput(classDeclarations,
                static (spc, source) => Execute(spc, source));
        }

        private static void Execute(SourceProductionContext context, GeneratorAttributeSyntaxContext attributeContext)
        {
            if (attributeContext.TargetSymbol is not INamedTypeSymbol classSymbol)
            {
                return;
            }

            AttributeData attributeData = attributeContext.Attributes[0];

            string? prefix = null;
            string? salt = null;

            foreach (var arg in attributeData.NamedArguments)
            {
                if (arg.Key == "Prefix" && arg.Value.Value is string prefixValue)
                {
                    prefix = prefixValue;
                }
                else if (arg.Key == "Salt" && arg.Value.Value is string saltValue)
                {
                    salt = saltValue;
                }
            }

            bool hasErrors = ValidateAttributeParameters(context, attributeData, prefix, salt);

            if (!hasErrors)
            {
                string source = GeneratePartialClass(classSymbol, prefix!, salt!);
                context.AddSource($"{classSymbol.Name}.g.cs", source);
            }
        }

        private static bool ValidateAttributeParameters(SourceProductionContext context, AttributeData attributeData, string? prefix, string? salt)
        {
            salt = salt ?? "";
            prefix = prefix ?? "";

            bool hasErrors = false;
            var attributeSyntax = (AttributeSyntax)attributeData.ApplicationSyntaxReference!.GetSyntax();

            // --- Prefix Validations ---
            if (string.IsNullOrWhiteSpace(prefix))
            {
                context.ReportDiagnostic(Diagnostic.Create(PrefixNotSetError, attributeSyntax.GetLocation()));
                hasErrors = true;
            }
            else
            {
                if (prefix.Length > MaxPrefixLength)
                {
                    context.ReportDiagnostic(Diagnostic.Create(PrefixTooLongError, GetAttributeArgumentLocation(attributeSyntax, "Prefix"), prefix, MaxPrefixLength));
                    hasErrors = true;
                }
                if (prefix.Length < MinPrefixLength)
                {
                    context.ReportDiagnostic(Diagnostic.Create(PrefixTooShortError, GetAttributeArgumentLocation(attributeSyntax, "Prefix"), prefix, MinPrefixLength));
                    hasErrors = true;
                }
                if (prefix.Any(char.IsWhiteSpace))
                {
                    context.ReportDiagnostic(Diagnostic.Create(PrefixContainsWhitespaceError, GetAttributeArgumentLocation(attributeSyntax, "Prefix"), prefix));
                    hasErrors = true;
                }
            }

            // --- Salt Validations ---
            if (string.IsNullOrWhiteSpace(salt))
            {
                context.ReportDiagnostic(Diagnostic.Create(SaltNotSetError, attributeSyntax.GetLocation()));
                hasErrors = true;
            }
            else
            {
                if (salt.Length > MaxSaltLength)
                {
                    context.ReportDiagnostic(Diagnostic.Create(SaltTooLongError, GetAttributeArgumentLocation(attributeSyntax, "Salt"), MaxSaltLength));
                    hasErrors = true;
                }
                if (salt.Any(char.IsWhiteSpace))
                {
                    context.ReportDiagnostic(Diagnostic.Create(SaltContainsWhitespaceError, GetAttributeArgumentLocation(attributeSyntax, "Salt")));
                    hasErrors = true;
                }
            }

            return hasErrors;
        }

        private static Location GetAttributeArgumentLocation(AttributeSyntax attributeSyntax, string argName)
        {
            var argument = attributeSyntax.ArgumentList?.Arguments
                .FirstOrDefault(a => a.NameEquals?.Name.Identifier.Text == argName);

            return argument?.GetLocation() ?? attributeSyntax.GetLocation();
        }

        private static string GeneratePartialClass(INamedTypeSymbol classSymbol, string prefix, string salt)
        {
            string className = classSymbol.Name;
            string namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()}";

            return $@"// <auto-generated/>
#nullable enable

using System.Diagnostics.CodeAnalysis;

{namespaceName}
{{
    public partial class {className} : NextId.Identifier<{className}>, System.IParsable<{className}>
    {{
        private const string PrefixConst = ""{prefix}"";
        private const string SaltConst = ""{salt}"";

        protected override string Prefix => PrefixConst;
        protected override string Salt => SaltConst;

        /// <summary>
        /// Creates a new instance of {className} with a new value for the current time.
        /// </summary>
        private {className}() : base() {{ }}
        
        /// <summary>
        /// Creates a new instance of {className} with a new value for a specific time.
        /// </summary>
        public {className}(System.DateTimeOffset time) : base(time) {{ }}

        /// <summary>
        /// Creates an instance of {className} from an existing string value.
        /// </summary>
        private {className}(string value) : base(value) {{ }}

        /// <summary>
        /// Creates a new {className}.
        /// </summary>
        public static {className} NewId() => new();

        /// <summary>
        /// Parses a string into a {className}.
        /// </summary>
        public static {className} Parse(string s) => Parse(s, null);

        /// <summary>
        /// Parses a string into a {className}.
        /// </summary>
        public static {className} Parse(string s, System.IFormatProvider? provider) => new(s);

        /// <summary>
        /// Tries to parse a string into a {className}.
        /// </summary>
        public static bool TryParse([NotNullWhen(true)] string? s, [NotNullWhen(true)] out {className}? result)
        {{
            if (s is null)
            {{
                result = null;
                return false;
            }}

            try
            {{
                result = new {className}(s);
                return true;
            }}
            catch
            {{
                result = null;
                return false;
            }}
        }}

        /// <summary>
        /// Tries to parse a string into a {className}.
        /// </summary>
        public static bool TryParse([NotNullWhen(true)] string? s, System.IFormatProvider? provider, [NotNullWhen(true)] out {className}? result)
        {{
            if (s is null)
            {{
                result = null;
                return false;
            }}

            try
            {{
                result = new {className}(s);
                return true;
            }}
            catch
            {{
                result = null;
                return false;
            }}
        }}

        /// <summary>
        /// Checks if the given string is a valid {className}.
        /// </summary>
        public static bool IsValid(string value) => NextId.Identifier<{className}>.IsValid(value, PrefixConst, SaltConst);
    }}
}}
";
        }
    }
}